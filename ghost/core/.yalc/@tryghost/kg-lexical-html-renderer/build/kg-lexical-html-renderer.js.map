{"version":3,"file":"kg-lexical-html-renderer.js","sources":["utils/TextContent.js","transformers/index.js","convert-to-html-string.js","get-dynamic-data-nodes.js","LexicalHTMLRenderer.js"],"sourcesContent":["import { $isLinkNode } from '@lexical/link';\nimport { $isTextNode, $isLineBreakNode, TextNode } from 'lexical';\nconst FORMAT_TAG_MAP = {\n    bold: 'STRONG',\n    italic: 'EM',\n    strikethrough: 'S',\n    underline: 'U',\n    code: 'CODE',\n    subscript: 'SUB',\n    superscript: 'SUP',\n    highlight: 'MARK'\n};\nconst ensureDomProperty = (options) => {\n    return !!options.dom;\n};\n// Builds and renders text content, useful to ensure proper format tag opening/closing\n// and html escaping\nexport default class TextContent {\n    nodes;\n    exportChildren;\n    options;\n    constructor(exportChildren, options) {\n        if (ensureDomProperty(options) === false) {\n            // eslint-disable-next-line ghost/ghost-custom/no-native-error\n            throw new Error('TextContent requires a dom property in the options argument');\n        }\n        this.exportChildren = exportChildren;\n        this.options = options;\n        this.nodes = [];\n    }\n    addNode(node) {\n        this.nodes.push(node);\n    }\n    render() {\n        const document = this.options.dom.window.document;\n        const root = document.createElement('div');\n        let currentNode = root;\n        const openFormats = [];\n        for (let i = 0; i < this.nodes.length; i++) {\n            const node = this.nodes[i];\n            if ($isLineBreakNode(node)) {\n                currentNode.append(document.createElement('BR'));\n                continue;\n            }\n            if ($isLinkNode(node)) {\n                const anchor = document.createElement('A');\n                this._buildAnchorElement(anchor, node);\n                currentNode.append(anchor);\n                continue;\n            }\n            if ($isTextNode(node)) {\n                // shortcut format code for plain text\n                if (node.getFormat() === 0) {\n                    currentNode.append(node.getTextContent());\n                    continue;\n                }\n                // open format tags in correct order\n                const formatsToOpen = [];\n                // get base list of formats that need to open\n                Object.entries(FORMAT_TAG_MAP).forEach(([format]) => {\n                    if (node.hasFormat(format) && !openFormats.includes(format)) {\n                        formatsToOpen.push(format);\n                    }\n                });\n                // re-order formats to open based on next nodes - we want to make\n                // sure tags that will be kept open for later nodes are opened first\n                const remainingNodes = this.nodes.slice(i + 1);\n                // avoid checking any nodes after a link node because those cause all formats to close\n                const nextLinkNodeIndex = remainingNodes.findIndex(n => $isLinkNode(n));\n                const remainingSortNodes = nextLinkNodeIndex === -1 ? remainingNodes : remainingNodes.slice(0, nextLinkNodeIndex);\n                // ensure we're only working with text nodes as they're the only ones that can open/close formats\n                const remainingSortedTextNodes = remainingSortNodes.filter(n => $isTextNode(n));\n                formatsToOpen.sort((a, b) => {\n                    const aIndex = remainingSortedTextNodes.findIndex(n => n.hasFormat(a));\n                    const bIndex = remainingSortedTextNodes.findIndex(n => n.hasFormat(b));\n                    if (aIndex === -1) {\n                        return 1;\n                    }\n                    if (bIndex === -1) {\n                        return -1;\n                    }\n                    return aIndex - bIndex;\n                });\n                // open new tags\n                formatsToOpen.forEach((format) => {\n                    const formatTag = document.createElement(FORMAT_TAG_MAP[format]);\n                    currentNode.append(formatTag);\n                    currentNode = formatTag;\n                    openFormats.push(format);\n                });\n                // insert text\n                currentNode.append(node.getTextContent());\n                // close tags in correct order if next node doesn't have the format\n                // links are their own formatting islands so all formats need to close before a link\n                const nextNode = remainingNodes.find(n => $isTextNode(n) || $isLinkNode(n));\n                [...openFormats].forEach((format) => {\n                    if (!nextNode || $isLinkNode(nextNode) || (nextNode instanceof TextNode && !nextNode.hasFormat(format))) {\n                        currentNode = currentNode.parentNode;\n                        openFormats.pop();\n                    }\n                });\n                continue;\n            }\n        }\n        return root.innerHTML;\n    }\n    isEmpty() {\n        return this.nodes.length === 0;\n    }\n    clear() {\n        this.nodes = [];\n    }\n    // PRIVATE -----------------------------------------------------------------\n    _buildAnchorElement(anchor, node) {\n        // Only set the href if we have a URL, otherwise we get a link to the current page\n        if (node.getURL()) {\n            anchor.setAttribute('href', node.getURL());\n        }\n        if (node.getRel()) {\n            anchor.setAttribute('rel', node.getRel() || '');\n        }\n        anchor.innerHTML = this.exportChildren(node, this.options);\n    }\n}\n//# sourceMappingURL=TextContent.js.map","const elementTransformers = [\n    require('./element/paragraph'),\n    require('./element/heading'),\n    require('./element/list'),\n    require('./element/blockquote'),\n    require('./element/aside')\n];\nexport default elementTransformers;\n//# sourceMappingURL=index.js.map","import { $getRoot, $isElementNode, $isLineBreakNode, $isParagraphNode, $isTextNode } from 'lexical';\nimport { $isLinkNode } from '@lexical/link';\nimport { $isKoenigCard } from '@tryghost/kg-default-nodes';\nimport TextContent from './utils/TextContent';\nimport elementTransformers from './transformers';\nexport default function $convertToHtmlString(options = {}) {\n    const output = [];\n    const children = $getRoot().getChildren();\n    options.usedIdAttributes = options.usedIdAttributes || {};\n    for (const child of children) {\n        const result = exportTopLevelElementOrDecorator(child, options);\n        if (result !== null) {\n            output.push(result);\n        }\n    }\n    // Koenig keeps a blank paragraph at the end of a doc but we want to\n    // make sure it doesn't get rendered\n    const lastChild = children[children.length - 1];\n    if (lastChild && $isParagraphNode(lastChild) && lastChild.getTextContent().trim() === '') {\n        output.pop();\n    }\n    return output.join('');\n}\nfunction exportTopLevelElementOrDecorator(node, options) {\n    if ($isKoenigCard(node)) {\n        // NOTE: kg-default-nodes appends type in rare cases to make use of this functionality... with moving to typescript,\n        //  we should change this implementation because it's confusing, or we should override the DOMExportOutput type\n        const { element, type } = node.exportDOM(options);\n        switch (type) {\n            case 'inner':\n                return element.innerHTML;\n            case 'value':\n                if ('value' in element) {\n                    return element.value;\n                }\n                return '';\n            default:\n                return element.outerHTML;\n        }\n    }\n    if ($isElementNode(node)) {\n        // note: unsure why this type isn't being picked up from the import\n        for (const transformer of elementTransformers) {\n            if (transformer.export !== null) {\n                const result = transformer.export(node, options, _node => exportChildren(_node, options));\n                if (result !== null) {\n                    return result;\n                }\n            }\n        }\n    }\n    return $isElementNode(node) ? exportChildren(node, options) : null;\n}\nfunction exportChildren(node, options) {\n    const output = [];\n    const children = node.getChildren();\n    const textContent = new TextContent(exportChildren, options);\n    for (const child of children) {\n        if (!textContent.isEmpty() && !$isLineBreakNode(child) && !$isTextNode(child) && !$isLinkNode(child)) {\n            output.push(textContent.render());\n            textContent.clear();\n        }\n        if ($isLineBreakNode(child) || $isTextNode(child) || $isLinkNode(child)) {\n            textContent.addNode(child);\n        }\n        else if ($isElementNode(child)) {\n            output.push(exportChildren(child, options));\n        }\n    }\n    if (!textContent.isEmpty()) {\n        output.push(textContent.render());\n    }\n    return output.join('');\n}\n//# sourceMappingURL=convert-to-html-string.js.map","import { $getRoot } from 'lexical';\nimport { $isKoenigCard } from '@tryghost/kg-default-nodes';\nexport default function getDynamicDataNodes(editorState) {\n    const dynamicNodes = [];\n    editorState.read(() => {\n        const root = $getRoot();\n        const nodes = root.getChildren();\n        nodes.forEach((node) => {\n            if ($isKoenigCard(node) && node.hasDynamicData?.()) {\n                dynamicNodes.push(node);\n            }\n        });\n    });\n    return dynamicNodes;\n}\n//# sourceMappingURL=get-dynamic-data-nodes.js.map","import { createHeadlessEditor } from '@lexical/headless';\nimport { ListItemNode, ListNode } from '@lexical/list';\nimport { HeadingNode, QuoteNode } from '@lexical/rich-text';\nimport { LinkNode } from '@lexical/link';\nimport $convertToHtmlString from './convert-to-html-string';\nimport getDynamicDataNodes from './get-dynamic-data-nodes';\nimport jsdom from 'jsdom';\nexport function defaultOnError() {\n    // do nothing\n}\nexport const useLexicalHtmlRenderer = ({ dom, nodes, onError } = {}) => {\n    if (!dom) {\n        const { JSDOM } = jsdom;\n        dom = new JSDOM();\n    }\n    if (!nodes) {\n        nodes = [];\n    }\n    if (!onError) {\n        onError = defaultOnError;\n    }\n    const render = async (lexicalState, userOptions = {}) => {\n        const defaultOptions = {\n            target: 'html',\n            dom: dom\n        };\n        const options = Object.assign({}, defaultOptions, userOptions);\n        const DEFAULT_NODES = [\n            HeadingNode,\n            ListNode,\n            ListItemNode,\n            QuoteNode,\n            LinkNode,\n            ...nodes\n        ];\n        const editor = createHeadlessEditor({\n            nodes: DEFAULT_NODES,\n            onError: onError\n        });\n        const editorState = editor.parseEditorState(lexicalState);\n        // gather nodes that require dynamic data\n        const dynamicDataNodes = getDynamicDataNodes(editorState);\n        // fetch dynamic data\n        const renderData = new Map();\n        await Promise.all(dynamicDataNodes.map(async (node) => {\n            if (!node.getDynamicData) {\n                return;\n            }\n            const { key, data } = await node.getDynamicData(options);\n            renderData.set(key, data);\n        }));\n        options.renderData = renderData;\n        // set up editor with our state\n        editor.setEditorState(editorState);\n        // register transforms that clean up state for rendering\n        //registerRemoveAtLinkNodesTransform(editor);\n        // render\n        let html = '';\n        editor.update(async () => {\n            html = $convertToHtmlString(options);\n        });\n        return html;\n    };\n    return { render };\n};\nexport default class LexicalHTMLRenderer {\n    dom;\n    nodes;\n    onError;\n    constructor({ dom, nodes, onError } = {}) {\n        if (!dom) {\n            // eslint-disable-next-line @typescript-eslint/no-var-requires\n            //const jsdom = require('jsdom');\n            const { JSDOM } = jsdom;\n            this.dom = new JSDOM();\n        }\n        else {\n            this.dom = dom;\n        }\n        this.nodes = nodes || [];\n        this.onError = onError || defaultOnError;\n    }\n    async render(lexicalState, userOptions = {}) {\n        const defaultOptions = {\n            target: 'html',\n            dom: this.dom\n        };\n        const options = Object.assign({}, defaultOptions, userOptions);\n        const DEFAULT_NODES = [\n            HeadingNode,\n            ListNode,\n            ListItemNode,\n            QuoteNode,\n            LinkNode,\n            ...this.nodes\n        ];\n        const editor = createHeadlessEditor({\n            nodes: DEFAULT_NODES,\n            onError: this.onError\n        });\n        const editorState = editor.parseEditorState(lexicalState);\n        // gather nodes that require dynamic data\n        const dynamicDataNodes = getDynamicDataNodes(editorState);\n        // fetch dynamic data\n        const renderData = new Map();\n        await Promise.all(dynamicDataNodes.map(async (node) => {\n            if (!node.getDynamicData) {\n                return;\n            }\n            const { key, data } = await node.getDynamicData(options);\n            renderData.set(key, data);\n        }));\n        options.renderData = renderData;\n        // set up editor with our state\n        editor.setEditorState(editorState);\n        // register transforms that clean up state for rendering\n        //registerRemoveAtLinkNodesTransform(editor);\n        // render\n        let html = '';\n        editor.update(async () => {\n            html = $convertToHtmlString(options);\n        });\n        return html;\n    }\n}\n//# sourceMappingURL=LexicalHTMLRenderer.js.map"],"names":["$isLineBreakNode","$isLinkNode","$isTextNode","TextNode","$getRoot","$isParagraphNode","$isKoenigCard","$isElementNode","HeadingNode","ListNode","ListItemNode","QuoteNode","LinkNode","createHeadlessEditor"],"mappings":"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"}