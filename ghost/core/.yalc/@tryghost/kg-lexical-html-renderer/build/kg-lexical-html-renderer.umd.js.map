{"version":3,"file":"kg-lexical-html-renderer.umd.js","sources":["utils/TextContent.js","transformers/index.js","convert-to-html-string.js","get-dynamic-data-nodes.js","LexicalHTMLRenderer.js"],"sourcesContent":["import { $isLinkNode } from '@lexical/link';\nimport { $isTextNode, $isLineBreakNode, TextNode } from 'lexical';\nconst FORMAT_TAG_MAP = {\n    bold: 'STRONG',\n    italic: 'EM',\n    strikethrough: 'S',\n    underline: 'U',\n    code: 'CODE',\n    subscript: 'SUB',\n    superscript: 'SUP',\n    highlight: 'MARK'\n};\nconst ensureDomProperty = (options) => {\n    return !!options.dom;\n};\n// Builds and renders text content, useful to ensure proper format tag opening/closing\n// and html escaping\nexport default class TextContent {\n    nodes;\n    exportChildren;\n    options;\n    constructor(exportChildren, options) {\n        if (ensureDomProperty(options) === false) {\n            // eslint-disable-next-line ghost/ghost-custom/no-native-error\n            throw new Error('TextContent requires a dom property in the options argument');\n        }\n        this.exportChildren = exportChildren;\n        this.options = options;\n        this.nodes = [];\n    }\n    addNode(node) {\n        this.nodes.push(node);\n    }\n    render() {\n        const document = this.options.dom.window.document;\n        const root = document.createElement('div');\n        let currentNode = root;\n        const openFormats = [];\n        for (let i = 0; i < this.nodes.length; i++) {\n            const node = this.nodes[i];\n            if ($isLineBreakNode(node)) {\n                currentNode.append(document.createElement('BR'));\n                continue;\n            }\n            if ($isLinkNode(node)) {\n                const anchor = document.createElement('A');\n                this._buildAnchorElement(anchor, node);\n                currentNode.append(anchor);\n                continue;\n            }\n            if ($isTextNode(node)) {\n                // shortcut format code for plain text\n                if (node.getFormat() === 0) {\n                    currentNode.append(node.getTextContent());\n                    continue;\n                }\n                // open format tags in correct order\n                const formatsToOpen = [];\n                // get base list of formats that need to open\n                Object.entries(FORMAT_TAG_MAP).forEach(([format]) => {\n                    if (node.hasFormat(format) && !openFormats.includes(format)) {\n                        formatsToOpen.push(format);\n                    }\n                });\n                // re-order formats to open based on next nodes - we want to make\n                // sure tags that will be kept open for later nodes are opened first\n                const remainingNodes = this.nodes.slice(i + 1);\n                // avoid checking any nodes after a link node because those cause all formats to close\n                const nextLinkNodeIndex = remainingNodes.findIndex(n => $isLinkNode(n));\n                const remainingSortNodes = nextLinkNodeIndex === -1 ? remainingNodes : remainingNodes.slice(0, nextLinkNodeIndex);\n                // ensure we're only working with text nodes as they're the only ones that can open/close formats\n                const remainingSortedTextNodes = remainingSortNodes.filter(n => $isTextNode(n));\n                formatsToOpen.sort((a, b) => {\n                    const aIndex = remainingSortedTextNodes.findIndex(n => n.hasFormat(a));\n                    const bIndex = remainingSortedTextNodes.findIndex(n => n.hasFormat(b));\n                    if (aIndex === -1) {\n                        return 1;\n                    }\n                    if (bIndex === -1) {\n                        return -1;\n                    }\n                    return aIndex - bIndex;\n                });\n                // open new tags\n                formatsToOpen.forEach((format) => {\n                    const formatTag = document.createElement(FORMAT_TAG_MAP[format]);\n                    currentNode.append(formatTag);\n                    currentNode = formatTag;\n                    openFormats.push(format);\n                });\n                // insert text\n                currentNode.append(node.getTextContent());\n                // close tags in correct order if next node doesn't have the format\n                // links are their own formatting islands so all formats need to close before a link\n                const nextNode = remainingNodes.find(n => $isTextNode(n) || $isLinkNode(n));\n                [...openFormats].forEach((format) => {\n                    if (!nextNode || $isLinkNode(nextNode) || (nextNode instanceof TextNode && !nextNode.hasFormat(format))) {\n                        currentNode = currentNode.parentNode;\n                        openFormats.pop();\n                    }\n                });\n                continue;\n            }\n        }\n        return root.innerHTML;\n    }\n    isEmpty() {\n        return this.nodes.length === 0;\n    }\n    clear() {\n        this.nodes = [];\n    }\n    // PRIVATE -----------------------------------------------------------------\n    _buildAnchorElement(anchor, node) {\n        // Only set the href if we have a URL, otherwise we get a link to the current page\n        if (node.getURL()) {\n            anchor.setAttribute('href', node.getURL());\n        }\n        if (node.getRel()) {\n            anchor.setAttribute('rel', node.getRel() || '');\n        }\n        anchor.innerHTML = this.exportChildren(node, this.options);\n    }\n}\n//# sourceMappingURL=TextContent.js.map","const elementTransformers = [\n    require('./element/paragraph'),\n    require('./element/heading'),\n    require('./element/list'),\n    require('./element/blockquote'),\n    require('./element/aside')\n];\nexport default elementTransformers;\n//# sourceMappingURL=index.js.map","import { $getRoot, $isElementNode, $isLineBreakNode, $isParagraphNode, $isTextNode } from 'lexical';\nimport { $isLinkNode } from '@lexical/link';\nimport { $isKoenigCard } from '@tryghost/kg-default-nodes';\nimport TextContent from './utils/TextContent';\nimport elementTransformers from './transformers';\nexport default function $convertToHtmlString(options = {}) {\n    const output = [];\n    const children = $getRoot().getChildren();\n    options.usedIdAttributes = options.usedIdAttributes || {};\n    for (const child of children) {\n        const result = exportTopLevelElementOrDecorator(child, options);\n        if (result !== null) {\n            output.push(result);\n        }\n    }\n    // Koenig keeps a blank paragraph at the end of a doc but we want to\n    // make sure it doesn't get rendered\n    const lastChild = children[children.length - 1];\n    if (lastChild && $isParagraphNode(lastChild) && lastChild.getTextContent().trim() === '') {\n        output.pop();\n    }\n    return output.join('');\n}\nfunction exportTopLevelElementOrDecorator(node, options) {\n    if ($isKoenigCard(node)) {\n        // NOTE: kg-default-nodes appends type in rare cases to make use of this functionality... with moving to typescript,\n        //  we should change this implementation because it's confusing, or we should override the DOMExportOutput type\n        const { element, type } = node.exportDOM(options);\n        switch (type) {\n            case 'inner':\n                return element.innerHTML;\n            case 'value':\n                if ('value' in element) {\n                    return element.value;\n                }\n                return '';\n            default:\n                return element.outerHTML;\n        }\n    }\n    if ($isElementNode(node)) {\n        // note: unsure why this type isn't being picked up from the import\n        for (const transformer of elementTransformers) {\n            if (transformer.export !== null) {\n                const result = transformer.export(node, options, _node => exportChildren(_node, options));\n                if (result !== null) {\n                    return result;\n                }\n            }\n        }\n    }\n    return $isElementNode(node) ? exportChildren(node, options) : null;\n}\nfunction exportChildren(node, options) {\n    const output = [];\n    const children = node.getChildren();\n    const textContent = new TextContent(exportChildren, options);\n    for (const child of children) {\n        if (!textContent.isEmpty() && !$isLineBreakNode(child) && !$isTextNode(child) && !$isLinkNode(child)) {\n            output.push(textContent.render());\n            textContent.clear();\n        }\n        if ($isLineBreakNode(child) || $isTextNode(child) || $isLinkNode(child)) {\n            textContent.addNode(child);\n        }\n        else if ($isElementNode(child)) {\n            output.push(exportChildren(child, options));\n        }\n    }\n    if (!textContent.isEmpty()) {\n        output.push(textContent.render());\n    }\n    return output.join('');\n}\n//# sourceMappingURL=convert-to-html-string.js.map","import { $getRoot } from 'lexical';\nimport { $isKoenigCard } from '@tryghost/kg-default-nodes';\nexport default function getDynamicDataNodes(editorState) {\n    const dynamicNodes = [];\n    editorState.read(() => {\n        const root = $getRoot();\n        const nodes = root.getChildren();\n        nodes.forEach((node) => {\n            if ($isKoenigCard(node) && node.hasDynamicData?.()) {\n                dynamicNodes.push(node);\n            }\n        });\n    });\n    return dynamicNodes;\n}\n//# sourceMappingURL=get-dynamic-data-nodes.js.map","import { createHeadlessEditor } from '@lexical/headless';\nimport { ListItemNode, ListNode } from '@lexical/list';\nimport { HeadingNode, QuoteNode } from '@lexical/rich-text';\nimport { LinkNode } from '@lexical/link';\nimport $convertToHtmlString from './convert-to-html-string';\nimport getDynamicDataNodes from './get-dynamic-data-nodes';\nimport jsdom from 'jsdom';\nexport function defaultOnError() {\n    // do nothing\n}\nexport const useLexicalHtmlRenderer = ({ dom, nodes, onError } = {}) => {\n    if (!dom) {\n        const { JSDOM } = jsdom;\n        dom = new JSDOM();\n    }\n    if (!nodes) {\n        nodes = [];\n    }\n    if (!onError) {\n        onError = defaultOnError;\n    }\n    const render = async (lexicalState, userOptions = {}) => {\n        const defaultOptions = {\n            target: 'html',\n            dom: dom\n        };\n        const options = Object.assign({}, defaultOptions, userOptions);\n        const DEFAULT_NODES = [\n            HeadingNode,\n            ListNode,\n            ListItemNode,\n            QuoteNode,\n            LinkNode,\n            ...nodes\n        ];\n        const editor = createHeadlessEditor({\n            nodes: DEFAULT_NODES,\n            onError: onError\n        });\n        const editorState = editor.parseEditorState(lexicalState);\n        // gather nodes that require dynamic data\n        const dynamicDataNodes = getDynamicDataNodes(editorState);\n        // fetch dynamic data\n        const renderData = new Map();\n        await Promise.all(dynamicDataNodes.map(async (node) => {\n            if (!node.getDynamicData) {\n                return;\n            }\n            const { key, data } = await node.getDynamicData(options);\n            renderData.set(key, data);\n        }));\n        options.renderData = renderData;\n        // set up editor with our state\n        editor.setEditorState(editorState);\n        // register transforms that clean up state for rendering\n        //registerRemoveAtLinkNodesTransform(editor);\n        // render\n        let html = '';\n        editor.update(async () => {\n            html = $convertToHtmlString(options);\n        });\n        return html;\n    };\n    return { render };\n};\nexport default class LexicalHTMLRenderer {\n    dom;\n    nodes;\n    onError;\n    constructor({ dom, nodes, onError } = {}) {\n        if (!dom) {\n            // eslint-disable-next-line @typescript-eslint/no-var-requires\n            //const jsdom = require('jsdom');\n            const { JSDOM } = jsdom;\n            this.dom = new JSDOM();\n        }\n        else {\n            this.dom = dom;\n        }\n        this.nodes = nodes || [];\n        this.onError = onError || defaultOnError;\n    }\n    async render(lexicalState, userOptions = {}) {\n        const defaultOptions = {\n            target: 'html',\n            dom: this.dom\n        };\n        const options = Object.assign({}, defaultOptions, userOptions);\n        const DEFAULT_NODES = [\n            HeadingNode,\n            ListNode,\n            ListItemNode,\n            QuoteNode,\n            LinkNode,\n            ...this.nodes\n        ];\n        const editor = createHeadlessEditor({\n            nodes: DEFAULT_NODES,\n            onError: this.onError\n        });\n        const editorState = editor.parseEditorState(lexicalState);\n        // gather nodes that require dynamic data\n        const dynamicDataNodes = getDynamicDataNodes(editorState);\n        // fetch dynamic data\n        const renderData = new Map();\n        await Promise.all(dynamicDataNodes.map(async (node) => {\n            if (!node.getDynamicData) {\n                return;\n            }\n            const { key, data } = await node.getDynamicData(options);\n            renderData.set(key, data);\n        }));\n        options.renderData = renderData;\n        // set up editor with our state\n        editor.setEditorState(editorState);\n        // register transforms that clean up state for rendering\n        //registerRemoveAtLinkNodesTransform(editor);\n        // render\n        let html = '';\n        editor.update(async () => {\n            html = $convertToHtmlString(options);\n        });\n        return html;\n    }\n}\n//# sourceMappingURL=LexicalHTMLRenderer.js.map"],"names":["FORMAT_TAG_MAP","bold","italic","strikethrough","underline","code","subscript","superscript","highlight","ensureDomProperty","options","dom","TextContent","nodes","exportChildren","constructor","Error","addNode","node","push","render","document","window","root","createElement","currentNode","openFormats","i","length","$isLineBreakNode","append","$isLinkNode","anchor","_buildAnchorElement","$isTextNode","getFormat","getTextContent","formatsToOpen","Object","entries","forEach","format","hasFormat","includes","remainingNodes","slice","nextLinkNodeIndex","findIndex","n","remainingSortNodes","remainingSortedTextNodes","filter","sort","a","b","aIndex","bIndex","formatTag","nextNode","find","TextNode","parentNode","pop","innerHTML","isEmpty","clear","getURL","setAttribute","getRel","elementTransformers","require","$convertToHtmlString","output","children","$getRoot","getChildren","usedIdAttributes","child","result","exportTopLevelElementOrDecorator","lastChild","$isParagraphNode","trim","join","$isKoenigCard","element","type","exportDOM","value","outerHTML","$isElementNode","transformer","export","_node","textContent","getDynamicDataNodes","editorState","dynamicNodes","read","hasDynamicData","defaultOnError","useLexicalHtmlRenderer","onError","JSDOM","jsdom","lexicalState","userOptions","defaultOptions","target","assign","DEFAULT_NODES","HeadingNode","ListNode","ListItemNode","QuoteNode","LinkNode","editor","createHeadlessEditor","parseEditorState","dynamicDataNodes","renderData","Map","Promise","all","map","getDynamicData","key","data","set","setEditorState","html","update"],"mappings":"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"}